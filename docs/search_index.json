[["index.html", "Appalachian National Scenic Trail Forest Health Monitoring - Standard Operating Procedures Chapter 1 Background 1.1 Forest Inventory and Analysis Program (FIA) 1.2 SOP Usage", " Appalachian National Scenic Trail Forest Health Monitoring - Standard Operating Procedures Northeast Temperate Network - National Park Service 2024-04-09 Chapter 1 Background 1.1 Forest Inventory and Analysis Program (FIA) The U.S. Forest Service (USFS) administers the Forest Inventory and Analysis Program to acquire inventory data on U.S. forests. The program was launched following the McSweeney - McNary Forest Research Act of 1928 (P.L. 70-466) which led to the first forests being inventoried in 1930 (USFS 2012). Data collected by the program are valuable for a variety of purposes, including timber harvest and ecological health. According to the FIA website, “…FIA reports on status and trends in forest area and location; in the species, size, and health of trees; in total tree growth, mortality, and removals by harvest; in wood production and utilization rates by various products; and in forest land ownership…”FIA data are organized by state, but all state datasets conform to a consistent format. However, in order to use FIA data for the Appalachian National Scenic Trail (APPA), data must be re-aggregated to the APPA area of interest. This document describes how to use the rFIA R package (Stanke et al. 2020) to download USFS FIA data and estimate forest attributes described in the APPA Forest Health Protocol (Dieffenbach 2018). The FIA program conducts annual (panel) inventories within each state. For the APPA region, this is most often a series of 5 annual, spatially unbiased inventories within each sampling cycle. This panel structure allows the FIA program to improve the precision of status and change estimates by leveraging previously collected data within an inventory cycle (e.g., estimate for 2015 may include data from annual inventories conducted from 2010-2015). This document illustrates how to use the functions in rFIA to: Access FIA data Subset the FIA data frame to the APPA HUC10 Shell Produce the following estimates, typically at the plot- and ecoregion-scale: Live tree abundance TPA, BAA, biomass, and carbon by species Species diversity of live trees Shannon’s diversity, evenness, and richness Tree vital rates Annual diameter, basal area, and biomass growth by species Forest demographic rates Annual recruitment and mortality rates by species Regeneration abundance TPA of seedlings and saplings by species and size-class Snag abundance TPA, BAA, biomass, carbon, relative fraction Down woody debris abundance Volume, biomass, and carbon by fuel class Invasive Plant abundance % cover by species Stand structural stage distributions % area in pole, mature, and late stage forest This document does not describe the FIA database structure or demonstrate all of the functionality of the rFIA package functions. Readers should consult the documentation within the rFIA package for specific function details. Some additional rFIA references include: rFIA github page https://github.com/hunter-stanke/rFIA rFIA package documentation on CRAN: https://rdrr.io/cran/rFIA/ rFIA tutorials page: https://rfia.netlify.app/ 1.2 SOP Usage This SOP was written in R using Rmarkdown and the associated bookdown package. Each “Chapter” of this SOP (e.g. 1-Background, 2-Download, 3-Clip, etc.) is a separate .Rmd file that can be opened and executed to create the actual files and tables described within a chapter. The most recent, working copies of .Rmd files can be found within the (APPAForest github repo) . Because the SOP and the executable code are one and the same, when the R code within the .Rmd is updated, so is the SOP. Furthermore, when the supporting text describing the procedures are updated via the SOP text, the intent of the code should remain clear to the code editor. There are other advantages to the SOP and R code originated from the same source. Namely, this approach saves time (one location to update), reduces the chance of errors, and helps avoid the tendency of an SOP to become asynchronous and out of date with intended procedures. 1.2.1 Annotations Several annotations are used throughout the SOP. Examples follow: These messages highlight broken code that requires a fix. These messages highlight a choice made that may need further examination. Blue code chunks like this highlight user input options to change functionality: # User input needed in these code chunks example_variable &lt;- TRUE 1.2.2 Run vs. Render To produce the desired APPA .csv files needed for the forest health report, you must Run the individual .Rmd files (see “Run .Rmd files” section). However, to create the SOP document, you will need to Render all the .Rmd files together into one document (see “Render SOP” section). 1.2.3 Run .Rmd files The .Rmd files presented here need to be run in sequential order to produce the APPA FIA data files. Each .Rmd file (except for index.Rmd) has externally saved output (see table 1.1) with the subsequent file utilizing the output from the previous file. The reason the .Rmd is split into different files (instead of one file) is because 01-download.Rmd and 02-clip.Rmd are time intensive (i.e. computer processor intensive) steps and the user will not want to run these steps more than once. The last .Rmd file, 03-make.Rmd, selects the appropriate dataset details for use in the APPA report and will likely need periodic updates/edits. Separating 03-make.Rmd from the first two steps allows the dataset details to be adjusted without having to redo the initial, time-intensive download and clip steps. index.Rmd - This chapter, 1 Background, is (and must be) named index.Rmd and contains important header information (not displayed in the final rendered SOP document) which tells R the desired parameters for how the document should be rendered (see “Render SOP” section). All other .Rmd files are named according to their corresponding chapter names in this SOP. Note that index.html will be the homepage if the SOP document is rendered as a HTML file. To generate the APPA FIA data files, open a .Rmd file (starting with 01-download.Rmd) and select Run All button from Rstudio or press Ctrl + Alt + R. Table 1.1: The .Rmd files and the corresponding file dataset output. .Rmd Output index.Rmd None download.Rmd .csv files of FIA data for all APPA states (multiple FIA files per state) clip.Rmd one .csv file of all FIA plot data within APPA region make.Rmd .csv files containing data for each FIA forest measurement type in APPA region. 1.2.4 Render SOP If edits have been made to one or more of the .Rmd files, the SOP can be rendered as a new document (.pdf, .html, word doc). You can render the HTML version of this SOP in R by installing the `bookdown` package, opening the bookdown project file (located within the github repo. For example APPA_SOP.proj), then: Find the Build pane in the RStudio IDE, and Click on Build Book, then select your output format, or select “All formats” if you’d like to use multiple formats from the same book source files. Or build the book from the R console: bookdown::render_book() To render to a PDF as a bookdown::pdf_book, you’ll need to install XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.org/tinytex/. Run and Render? - Note that when rendering the document the R code itself will not run because eval = FALSE in the code chunk at the beginning of the index.Rmd file. knitr::opts_chunk$set( eval = FALSE ) If eval = TRUE all R code would run in addition to rendering the SOP document. This is not recommended as processes in the initial .Rmd files (downloading and clipping) are time-intensive and best run separately (see “Run .Rmd files” section). Preview SOP - R studio and bookdown offer different options to preview what the rendered document will look like in real time (updates as you edit) without having to render the entire document. You can start the live preview through the Rstudio interface by selecting the “visual” mode instead of “source” mode. Another option is to start the live preview directly from the R console: bookdown::serve_book() "],["download.html", "Chapter 2 Download FIA 2.1 Install rFIA package 2.2 Setup parallel processing 2.3 Download FIA data for each state intersecting APPA", " Chapter 2 Download FIA Note that as of 03 Mar 2024 the rFIA R package has not been updated for approximately 1 year. Therefore, some functionality has been lost because the package is not being actively maintained. For example, downloading FIA data for multiple states using the getFIA() function currently results in an error due to recent updates to the online FIA database (FIA DataMart). Currently, there are two suggested work-arounds: 1) Download the outdated package and manually fix the source code, or 2) Download the rFIA package from an alternative repo with some fixes already applied. 2.1 Install rFIA package 2.1.1 Option 1: Install rFIA from offical repo, then manually fix package: remotes::install_github(&quot;hunter-stanke/rFIA&quot;) library(rFIA) # Then, edit the source code of the package using the changes outlined here: # https://github.com/hunter-stanke/rFIA/pull/46/files 2.1.2 Option 2: Install rFIA from alternative repo: Issue with multi-state download request fixed in this version below. But note that this copy is only supplied as a temporary solution and is also not being actively updated or maintained. remotes::install_github(&quot;jakegross808/rFIA&quot;) library(rFIA) 2.2 Setup parallel processing Setting up parallel processing in R may help with downloading extensive amounts of data from the FIA datamart: ## How many physical cores do you have? parallel::detectCores(logical = FALSE) ## How many cores do you want to use? ## If you still want to use your computer for anything else during the computations ## (e.g., checking your E-mails or writing a Word document), ## you should reserve at least one core for those remaining tasks. cores &lt;- parallel::detectCores(logical = FALSE)-2 # set to use all physical cores minus number needed for other processes. 2.3 Download FIA data for each state intersecting APPA The rFIA function getFIA()(https://rdrr.io/cran/rFIA/man/getFIA.html) downloads State FIA Data from the FIA Datamart. 2.3.1 Test Run Use the small “test dataset” below to see if the function is working properly before downloading the very large Appalachian trail dataset. Test dataset consists of a small amount of FIA data from US territories, American Samoa and Guam. ## Small subset of FIA dataset to test &#39;getFIA()&#39; before big download test &lt;- c(&#39;AS&#39;, &#39;GU&#39;) # smallest datasets in 2023 ## If dir = NULL tables will not be saved on disk and only loaded into R environment test_FIA_db_object &lt;- getFIA(states = test, dir = NULL, nCores = cores) str(test_FIA_db_object) 2.3.2 Save location Choose where local FIA database tables will be saved: ## default location: save_default &lt;- &#39;./download_FIA/&#39; ## Alternatively, enter specific custom location: save_custom &lt;- &#39;C:/Users/JJGross/Documents/R_projects/FIA_data/allStates&#39; ## Specify `save_location &lt;- save_custom` or `save_location &lt;- save_default` save_location &lt;- save_custom ## Create directory if it doesn&#39;t already exist if (!dir.exists(save_location)) {dir.create(save_location)} 2.3.3 Download all FIA data from all 13 APPA states: This is a large amount of data and depending on connection, may take more than an hour to complete. Note that load = FALSE saves the dataset to hard drive location instead of loading directly into R session. The dataset saved to the hard drive will be loaded into R using steps outlined in the next chapter. “Clip”. Argument common = TRUE only imports the most commonly used FIA tables, including all those required for rFIA functions. ## APPA States at_states &lt;- c(&#39;CT&#39;, &#39;GA&#39;, &#39;ME&#39;, &#39;MD&#39;, &#39;MA&#39;, &#39;NH&#39;, &#39;NJ&#39;, &#39;NY&#39;, &#39;NC&#39;, &#39;PA&#39;, &#39;TN&#39;, &#39;VT&#39;, &#39;VA&#39;) ## Download the data: getFIA(states = at_states, dir = save_location, nCores = cores, common = TRUE, load = FALSE) "],["clip.html", "Chapter 3 Clip by Ecoregion 3.1 Location to save output 3.2 Load ‘Ecoregions’ spatial data 3.3 Read FIA data into R 3.4 Clip FIA plots by Ecoregion 3.5 Supporting tables 3.6 Check plot attributes final", " Chapter 3 Clip by Ecoregion 3.1 Location to save output ## default location: save_default &lt;- &#39;./clip_FIA/&#39; ## Alternatively, enter specific custom location: save_custom &lt;- &#39;C:/Users/JJGross/Documents/R_projects/FIA_data/clip_FIA/&#39; ## Specify `save_location &lt;- save_custom` or `save_location &lt;- save_default` save_location &lt;- save_custom ## Create directory if it doesn&#39;t already exist if (!dir.exists(save_location)) {dir.create(save_location)} 3.2 Load ‘Ecoregions’ spatial data Load in a file containing hierarchical spatial categories, or levels, of polygons surrounding the Appalachian National Scenic Trail (more info on how this file was created can be found in APPA Forest Health FIA Narrative). The hierarchical spatial levels (from smallest to largest) include ecological subsections, ecological sections, and provinces (all collectively referred to as ecoregions here). The APPA Ecoregions dataset can be downloaded from IRMA: APPA_Ecoregions_USFS_HUC10_Shell_AEA load_eco_path &lt;- &quot;C:/Users/JJGross/Downloads/APPA_Ecoregions_USFS_HUC10_Shell_AEA&quot; Read the shapefile using read_sf() from the sf (simple features) package. eco_shapefile &lt;- sf::read_sf(dsn = load_eco_path, layer = &#39;APPA_Ecoregions_USFS_HUC10_Shell_AEA&#39;) 3.2.1 Explore ecoregion levels: plot(eco_shapefile[&quot;SUBSECTION&quot;]) plot(eco_shapefile[&quot;SECTION_NA&quot;]) ## SUBSECTIONS: n_distinct(eco_shapefile$SUBSECTION) ## [1] 50 levels(as.factor(eco_shapefile$SUBSECTION)) ## [1] &quot;211Aa&quot; &quot;211Ba&quot; &quot;211Bb&quot; &quot;211Da&quot; &quot;211Ec&quot; &quot;211Fc&quot; &quot;211Fd&quot; &quot;211Ia&quot; ## [9] &quot;221Ae&quot; &quot;221Al&quot; &quot;221Am&quot; &quot;221Ba&quot; &quot;221Bb&quot; &quot;221Bd&quot; &quot;221Da&quot; &quot;221Db&quot; ## [17] &quot;221Dc&quot; &quot;221Dd&quot; &quot;221De&quot; &quot;221Ja&quot; &quot;221Jb&quot; &quot;221Jc&quot; &quot;231Ab&quot; &quot;231Ac&quot; ## [25] &quot;231Ad&quot; &quot;231Ag&quot; &quot;231Ib&quot; &quot;M211Ab&quot; &quot;M211Ac&quot; &quot;M211Ad&quot; &quot;M211Ae&quot; &quot;M211Af&quot; ## [33] &quot;M211Ag&quot; &quot;M211Ba&quot; &quot;M211Bb&quot; &quot;M211Bc&quot; &quot;M211Ca&quot; &quot;M211Cb&quot; &quot;M211Cc&quot; &quot;M211Cd&quot; ## [41] &quot;M221Aa&quot; &quot;M221Ab&quot; &quot;M221Ac&quot; &quot;M221Ad&quot; &quot;M221Be&quot; &quot;M221Cb&quot; &quot;M221Da&quot; &quot;M221Db&quot; ## [49] &quot;M221Dc&quot; &quot;M221Dd&quot; ## SUBSECTI_1: levels(as.factor(eco_shapefile$SUBSECTI_1)) ## [1] &quot;Aroostook Hills&quot; ## [2] &quot;Berkshire-Vermont Upland&quot; ## [3] &quot;Catskill Mountains&quot; ## [4] &quot;Central Blue Ridge Mountains&quot; ## [5] &quot;Central Maine Embayment&quot; ## [6] &quot;Central Maine Foothills&quot; ## [7] &quot;Champlain Glacial Lake and Marine Plains&quot; ## [8] &quot;Connecticut Lakes&quot; ## [9] &quot;Eastern Allegheny Plateau&quot; ## [10] &quot;Eastern Coal Fields&quot; ## [11] &quot;Gettysburg Piedmont Lowland&quot; ## [12] &quot;Great Valley of Virginia&quot; ## [13] &quot;Holston Valley&quot; ## [14] &quot;Hudson Highlands&quot; ## [15] &quot;Hudson Limestone Valley&quot; ## [16] &quot;Kittatinny-Shawangunk Ridges&quot; ## [17] &quot;Lower Foot Hills&quot; ## [18] &quot;Lynchburg Belt&quot; ## [19] &quot;Mahoosic Rangely Lakes&quot; ## [20] &quot;Maine-New Brunswick Lowlands&quot; ## [21] &quot;Maine Central Mountains&quot; ## [22] &quot;Metasedimentary Mountains&quot; ## [23] &quot;Newark&quot; ## [24] &quot;Northern Blue Ridge Mountains&quot; ## [25] &quot;Northern Great Valley&quot; ## [26] &quot;Northern Green Mountain&quot; ## [27] &quot;Northern Piedmont&quot; ## [28] &quot;Northern Ridge and Valley&quot; ## [29] &quot;Piedmont Ridge&quot; ## [30] &quot;Piedmont Upland&quot; ## [31] &quot;Pocono Plateau&quot; ## [32] &quot;Reading Prong&quot; ## [33] &quot;Ridge and Valley&quot; ## [34] &quot;Rolling Limestone Hills&quot; ## [35] &quot;Sandstone Hills&quot; ## [36] &quot;Schist Hills&quot; ## [37] &quot;Schist Plains&quot; ## [38] &quot;Sebago-Ossipee Hills and Plains&quot; ## [39] &quot;Southern Blue Ridge Mountains&quot; ## [40] &quot;Southern Green Mountain&quot; ## [41] &quot;Southern Piedmont&quot; ## [42] &quot;St. John Upland&quot; ## [43] &quot;Sunapee Uplands&quot; ## [44] &quot;Taconic Foothills&quot; ## [45] &quot;Taconic Mountains&quot; ## [46] &quot;Triassic Basins&quot; ## [47] &quot;Western Allegheny Mountain and Valley&quot; ## [48] &quot;Western Maine Foothills&quot; ## [49] &quot;White Mountains&quot; n_distinct(eco_shapefile$SUBSECTI_1) ## [1] 49 ## Note that &#39;SUBSECTI_1&#39; names are not unique - there are two different &quot;Northern Piedmont&quot; eco_shapefile %&gt;% filter(SUBSECTI_1 == &quot;Northern Piedmont&quot;) %&gt;% select(SUBSECTI_1, SUBSECTION, SECTION_NA, PROVINCE_N) %&gt;% sf::st_drop_geometry() ## # A tibble: 2 × 4 ## SUBSECTI_1 SUBSECTION SECTION_NA PROVINCE_N ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Northern Piedmont M211Ba New England Piedmont Adirondack-New Eng… ## 2 Northern Piedmont 221De Northern Appalachian Piedmont Eastern Broadleaf … eco_shapefile &lt;- eco_shapefile %&gt;% mutate(SUBSECTI_1 = case_when( SUBSECTI_1 == &quot;Northern Piedmont&quot; &amp; SUBSECTION == &quot;M211Ba&quot; ~ &quot;New Engl. Northern Piedmont&quot;, SUBSECTI_1 == &quot;Northern Piedmont&quot; &amp; SUBSECTION == &quot;221De&quot; ~ &quot;Appal. Northern Piedmont&quot;, .default = as.character(SUBSECTI_1))) Note that SUBSECTI_1 names are not unique. There are two different subsections both named “Northern Piedmont”. See current re-name solution above. ## Distinct SECTION_NA: n_distinct(eco_shapefile$SECTION_NA) ## [1] 19 levels(as.factor(eco_shapefile$SECTION_NA)) ## [1] &quot;Allegheny Mountains&quot; ## [2] &quot;Aroostook Hills and Lowlands&quot; ## [3] &quot;Blue Ridge Mountains&quot; ## [4] &quot;Catskill Mountains&quot; ## [5] &quot;Central Appalachian Piedmont&quot; ## [6] &quot;Central Maine Coastal and Embayment&quot; ## [7] &quot;Central Ridge and Valley&quot; ## [8] &quot;Green-Taconic-Berkshire Mountains&quot; ## [9] &quot;Hudson Valley&quot; ## [10] &quot;Lower New England&quot; ## [11] &quot;Maine - New Brunswick Foothills and Lowlands&quot; ## [12] &quot;New England Piedmont&quot; ## [13] &quot;Northern Appalachian Piedmont&quot; ## [14] &quot;Northern Cumberland Mountains&quot; ## [15] &quot;Northern Glaciated Allegheny Plateau&quot; ## [16] &quot;Northern Ridge and Valley&quot; ## [17] &quot;Southern Appalachian Piedmont&quot; ## [18] &quot;St. Lawrence and Champlain Valley&quot; ## [19] &quot;White Mountains&quot; ## Distinct PROVINCE_N: n_distinct(eco_shapefile$PROVINCE_N) ## [1] 5 levels(as.factor(eco_shapefile$PROVINCE_N)) ## [1] &quot;Adirondack-New England Mixed Forest--Coniferous Forest--Alpine Meadow&quot; ## [2] &quot;Central Appalachian Broadleaf Forest-Coniferous Forest-Meadow&quot; ## [3] &quot;Eastern Broadleaf Forest&quot; ## [4] &quot;Northeastern Mixed Forest&quot; ## [5] &quot;Southeastern Mixed Forest&quot; 3.3 Read FIA data into R Load the FIA data stored locally (From “Download Chapter) into R session. ## load from default location (specified in 01-Download.Rmd chapter): load_default &lt;- &#39;./download_FIA/&#39; ## Alternatively, enter specific custom location: load_custom &lt;- &#39;C:/Users/JJGross/Documents/R_projects/FIA_data/allStates&#39; load_location &lt;- load_custom #load_location &lt;- load_default ## Change number of processing cores used, if desired cores &lt;- parallel::detectCores(logical = FALSE)-2 Read the FIA data stored locally (From “Download Chapter) using the ReadFIA() function. ## Specify the 13 APPA states by state code (this is extra insurance that the wrong states are not loaded, if other states have been downloaded to same directory) at_states &lt;- c(&#39;CT&#39;, &#39;GA&#39;, &#39;ME&#39;, &#39;MD&#39;, &#39;MA&#39;, &#39;NH&#39;, &#39;NJ&#39;, &#39;NY&#39;, &#39;NC&#39;, &#39;PA&#39;, &#39;TN&#39;, &#39;VT&#39;, &#39;VA&#39;) ## Read FIA data at_states_FIA &lt;- readFIA(dir = load_location, states = at_states, nCores = cores) 3.4 Clip FIA plots by Ecoregion clipFIA() performs space-time queries on Forest Inventory and Analysis Database (FIADB). clipFIA subsets the dataset to include only data associated with particular inventory years (i.e., most recent), and/or only data within a user-defined region. Spatially, the mask = eco argument below selects only the at_states_FIA FIA plots which fall within the perimeter of the eco spatial extent (i.e. the outer boundary of the ecoregion polygons). Temporally, the mostRecent argument returns only data for most recent inventory if set to TRUE ## Restrict to most recent inventory at_FIA_MR &lt;- clipFIA(at_states_FIA, matchEval = TRUE, mostRecent = TRUE, mask = eco_shapefile) saveRDS(at_FIA_MR, file = paste0(save_location, &quot;at_FIA_MR.rds&quot;)) ## Access all inventories at_FIA &lt;- clipFIA(at_states_FIA, matchEval = TRUE, mostRecent = FALSE, mask = eco_shapefile) saveRDS(at_FIA, file = paste0(save_location, &quot;at_FIA.rds&quot;)) Note the argument matchEval = TRUE in the above function. The clipFIA() documentation states that: “if matchEval = TRUE, clipFIA() returns a subset of data for which there are matching reporting years across states. Only useful if db contains multiple state subsets of the FIA database.” This seems appropriate for the Appalachian Trail dataset, but when compared (12 March 2024), both matchEval = TRUE and matchEval = FALSE appeared to result in the same output. This may have something to do with the method that is used (e.g. ‘Annual’“’ vs ‘TI’). Further evaluation is needed. Note that currently matchEval argument is set to matchEval = TRUE for both at_FIA and at_FIA_MR. Confirm this is appropriate. 3.4.1 Ecosubsections It is important to note the column ECOSUBCD which is part of the native FIA database and referenced in the FIA Database User Guide. The ECOSUBCD column can be included in the output of most rFIA functions with the argument grpBy = c(ECOSUBCD). The FIA database guide states that subsection codes for the conterminous United States were developed as part of the “Ecological Subregions: Sections and Subsections for the Conterminous United States” publication (Cleland et al. 2007). Conversely, the same ecoregional subsection code can be found within the APPA_Ecoregions_USFS_HUC10_Shell_AEA shapefile column eco$SUBSECTION along with additional related columns - for example, the full subsection name in the SUBSECTI_1 column. These columns (and others added below) are appended to the FIA dataset during most rFIA functions by way of the polys = eco. For this reason the polys = ecoargument is often more advantageous than the grpBy = c(ECOSUBCD) and the polys = ecoargument is utilized throughout the make.Rmd chapter. Note that this polys = eco argument is different than the rFIA::clipFIA(mask = eco) function/argument which only clips the plot data by the eco mask (outer spatial boundary) and does not append any data. 3.5 Supporting tables 3.5.1 Appalachian trail spatial centerline data ## Manually downloaded `Appalachian_National_Scenic_Trail.shp` from `APPAForesthealthReport` repo. centerline_shapefile_location &lt;- &quot;move_to_server/at_centerline/&quot; ## read in shapefile of Appalachian trail center-line at_centerline &lt;- sf::st_read(paste0(centerline_shapefile_location, &quot;Appalachian_National_Scenic_Trail.shp&quot;)) %&gt;% mutate(region_3cl = case_when( Region == &quot;New England&quot; ~ &quot;Northeast&quot;, Region == &quot;Mid-Atlantic&quot; ~ &quot;Mid-Atlantic&quot;, Region %in% c(&quot;Southern&quot;, &quot;Virginia&quot;) ~ &quot;Southeast&quot; )) saveRDS(at_centerline, paste0(save_location, &quot;at_centerline.rds&quot;)) Appalachian_National_Scenic_Trail.shp currently saved within APPAForesthealthReport repo. In future move this to appropriate location (e.g. IRMA). 3.5.2 APPA FIA plots Note that the rFIA::tpa() function was used below to calculate and construct tables for APPA FIA plot-level attributes (e.g. elevation, etc.). TPA was selected because it is a core metric of FIA methods and should be present in all field visited plots. ## Get plot-level data for the most recent tpa dataset tpa_plots_MR &lt;- rFIA::tpa(at_FIA_MR, byPlot = TRUE, grpBy = c(STATECD, ECOSUBCD, ELEV), returnSpatial = TRUE) ## Get plot-level data for full tpa dataset tpa_plots &lt;- rFIA::tpa(at_FIA, byPlot = TRUE, grpBy = c(STATECD, ECOSUBCD, ELEV), returnSpatial = TRUE) ## Get only the unique plot locations (pltID) ## i.e. exclude the revisits tpa_plots_by_year &lt;- tpa_plots |&gt; # HAVE TO DO BIND ROWS HERE BECAUSE `tpa_plots&#39; SUPRISINGLY DOES NOT # CONTAIN ALL PLOTS FOUND IN `tpa_plots_MR&#39;. # Error with rFIA discussed below dplyr::bind_rows(tpa_plots_MR) |&gt; dplyr::group_by(PLT_CN) |&gt; #PLT_CN is each unique event, while pltID is each unique plot location distinct() ## Get only the unique plot locations (pltID) ## i.e. exclude the revisits tpa_plots_distinct &lt;- tpa_plots_by_year |&gt; select(pltID, STATECD, ECOSUBCD, ELEV, geometry) %&gt;% distinct() Display APPA FIA plots by eco-subsection and southern most plot used to calculated distance. ## Select Southern-most plot most_S_plot &lt;- tpa_plots_distinct %&gt;% filter(pltID == &quot;5_13_85_5&quot;) ## ecosubsection colors ecosubCol &lt;- colorFactor(rainbow(51), tpa_plots_distinct$ECOSUBCD) ## leaflet map tpa_plots_distinct %&gt;% leaflet() %&gt;% addTiles() %&gt;% addCircleMarkers( color = ~ecosubCol(ECOSUBCD), stroke = FALSE, fillOpacity = 1, radius = 4) %&gt;% addMarkers(data = most_S_plot) Calculate each plot’s distance from southern point for use in displaying data as transect along axis. tpa_plots_distance &lt;- tpa_plots_distinct |&gt; mutate(S_plot = most_S_plot$geometry) |&gt; # add south point mutate(dist_unit = sf::st_distance( S_plot, geometry, by_element = TRUE)) |&gt; # calculate distance mutate(distance_m = round(as.numeric(dist_unit))) |&gt; select(-S_plot, -dist_unit) ## Create a continuous palette function dist_pal &lt;- colorNumeric(palette = &quot;Blues&quot;, domain = tpa_plots_distance$distance_m) ## leaflet map tpa_plots_distance %&gt;% leaflet() %&gt;% addTiles() %&gt;% addCircleMarkers( color = ~dist_pal(distance_m), stroke = FALSE, fillOpacity = 1, radius = 4) %&gt;% addMarkers(data = most_S_plot) Demo usage of plot attributes plot_attributes &lt;- tpa_plots_distance # Demo plot distance x elevation plot_attributes |&gt; group_by(ECOSUBCD)|&gt; mutate(median_dist = median(distance_m)) |&gt; mutate(median_elev = median(ELEV)) |&gt; ggplot(aes(x= fct_reorder(ECOSUBCD, distance_m), y=ELEV, fill = as.factor(median_elev))) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), legend.position = &#39;none&#39;) + xlab(&quot;Ecosubsection (from SW to NE)&quot;) + ylab(&quot;Plot Elevation&quot;) 3.5.2.1 Check Plot Counts Perform some checks on records within tpa dataset - helps gauge dataset changes. Can also add quality assurance checks here: ## Check that entire dataset (at_plots) contains most recent dataset (at_plots_MR) tpa_chk &lt;- sf::st_drop_geometry(tpa_plots) tpa_chk_MR &lt;- sf::st_drop_geometry(tpa_plots_MR) MRplots_not_in_full_tpa_dataset &lt;- anti_join(tpa_chk_MR, tpa_chk, by = join_by(pltID)) if (nrow(MRplots_not_in_full_tpa_dataset) != 0) { warning(&quot;tpa_plots does not contain all plots found in tpa_plots_MR (most recent) dataset&quot;) } ## Warning: tpa_plots does not contain all plots found in tpa_plots_MR (most ## recent) dataset ## total events/visits tpa_event_count &lt;- nrow(tpa_chk) tpa_event_count # 12,457 ## [1] 12457 ## total plot locations tpa_plot_count &lt;- length(unique(tpa_chk$pltID)) tpa_plot_count # 4,328 ## [1] 4328 tpa_plots_summary &lt;- tpa_chk |&gt; group_by(pltID) |&gt; summarise(visits = n()) |&gt; group_by(visits) |&gt; summarize(n_plots = n()) tpa_plots_summary ## # A tibble: 5 × 2 ## visits n_plots ## &lt;int&gt; &lt;int&gt; ## 1 1 571 ## 2 2 781 ## 3 3 1590 ## 4 4 1376 ## 5 5 10 ## In 2022 # 1 571 (571 plots measured once) # 2 781 (781 plots measured twice) # 3 1590 # 4 1376 # 5 10 ## total events/visits tpa_event_count_MR &lt;- nrow(tpa_chk_MR) tpa_event_count_MR # 3,980 ## [1] 3980 ## total plot locations tpa_plot_count_MR &lt;- length(unique(tpa_chk_MR$pltID)) tpa_plot_count_MR # 3,980 ## [1] 3980 if (tpa_event_count_MR != tpa_plot_count_MR) { warning(&quot;some plots not unique in most recent (MR) dataset&quot;) } Possible error with rFIA: tpa_plots (full dataset) does not contain all plots found in tpa_plots_MR (most recent) dataset” see MRplots_not_in_full_tpa_dataset for table of missing plots. 3.5.3 Subsections 3.5.3.1 Check subsections tpa_ECOSUBCD_distinct &lt;- tpa_plots_distinct |&gt; sf::st_drop_geometry() |&gt; distinct(ECOSUBCD) ## Eco shapefile: eco &lt;- eco_shapefile %&gt;% full_join(tpa_ECOSUBCD_distinct, by = c(&quot;SUBSECTION&quot; = &quot;ECOSUBCD&quot;)) %&gt;% sf::st_transform(&#39;+proj=longlat +datum=WGS84&#39;) ## return all rows from eco_shapefile without a match in FIA_plots ## These are subsections with no FIA plots: dplyr::anti_join(eco, tpa_ECOSUBCD_distinct, by = join_by(SUBSECTION == ECOSUBCD)) ## Simple feature collection with 3 features and 15 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -83.99575 ymin: 34.51386 xmax: -80.44353 ymax: 37.65403 ## Geodetic CRS: +proj=longlat +datum=WGS84 ## # A tibble: 3 × 16 ## AREA PERIMETER ECOMAP_200 ECOMAP_201 PROVINCE SECTION SUBSECTION DOMAIN_NAM ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 7.42e8 436121. 1232 1381 M221 M221B M221Be Humid Tem… ## 2 3.99e4 1265905. 1480 1590 221 221J 221Ja Humid Tem… ## 3 2.10e6 415055. 1688 1746 231 231A 231Ad Humid Tem… ## # ℹ 8 more variables: DIVISION_N &lt;chr&gt;, PROVINCE_N &lt;chr&gt;, SECTION_NA &lt;chr&gt;, ## # SUBSECTI_1 &lt;chr&gt;, ATIntersec &lt;int&gt;, Acres &lt;dbl&gt;, Hectares &lt;dbl&gt;, ## # geometry &lt;MULTIPOLYGON [°]&gt; ## return all rows from FIA_plots without a match in eco_shapefile ## These rows are locations with FIA plots but no subsection included in shapefile: eco %&gt;% filter(is.na(SECTION)) ## Simple feature collection with 1 feature and 15 fields (with 1 geometry empty) ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: NA ymin: NA xmax: NA ymax: NA ## Geodetic CRS: +proj=longlat +datum=WGS84 ## # A tibble: 1 × 16 ## AREA PERIMETER ECOMAP_200 ECOMAP_201 PROVINCE SECTION SUBSECTION DOMAIN_NAM ## * &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 NA NA NA NA &lt;NA&gt; &lt;NA&gt; M211Aa &lt;NA&gt; ## # ℹ 8 more variables: DIVISION_N &lt;chr&gt;, PROVINCE_N &lt;chr&gt;, SECTION_NA &lt;chr&gt;, ## # SUBSECTI_1 &lt;chr&gt;, ATIntersec &lt;int&gt;, Acres &lt;dbl&gt;, Hectares &lt;dbl&gt;, ## # geometry &lt;MULTIPOLYGON [°]&gt; 3.5.3.2 Missing eco$SUBSECTION info Note that eco shapefile is missing information for SUBSECTION M211Aa - International Boundary Plateau. This needs to be fixed in original shapefile. Temporary fix here: ## missing info found by google search of &quot;M211Aa&quot; # https://www.fs.usda.gov/research/publications/misc/73326-wo-gtr-76d-cleland2007.pdf missing_subsection &lt;- data.frame( PROVINCE = &quot;M211&quot;, SECTION = &quot;M211A&quot;, SUBSECTION = &quot;M211Aa&quot;, SECTION_NA = &quot;White Mountains&quot;, SUBSECTI_1 = &quot;International Boundary Plateau&quot;) eco &lt;- eco |&gt; filter(SUBSECTION != &quot;M211Aa&quot;) |&gt; bind_rows(missing_subsection) 3.5.3.3 Calculate n plots Calculate plots per subsection and median elevation and distance for all and most recent (MR) datasets # calculate plots per subsection plot_attributes_drop_geo &lt;- plot_attributes %&gt;% sf::st_drop_geometry() n_plots_tpa_MR &lt;- tpa_plots_MR |&gt; sf::st_drop_geometry() |&gt; left_join(plot_attributes_drop_geo, by = join_by(pltID, STATECD, ECOSUBCD, ELEV)) |&gt; group_by(ECOSUBCD) |&gt; summarize(n_plots_subsect_MR = n(), median_elevation_MR = median(ELEV), median_distance_MR = median(distance_m)) n_plots_tpa &lt;- tpa_plots |&gt; sf::st_drop_geometry() |&gt; left_join(plot_attributes_drop_geo, by = join_by(pltID, STATECD, ECOSUBCD, ELEV)) |&gt; group_by(ECOSUBCD) |&gt; summarize(n_plots_subsect = n(), median_elevation = median(ELEV), median_distance = median(distance_m)) 3.5.3.4 Add states and subsection abbreviations Shorter subsection names with states they occur in. ## Read in state code names state_codes &lt;- read_csv(&quot;move_to_server/us-state-ansi-fips.csv&quot;, show_col_types = FALSE) %&gt;% mutate(st = as.integer(st)) ## Get all subsections in one dataset (subsections from FIA + eco shapefile) ## Have to join because these can be different if subsection missing from eco shapefile ## or FIA data not collected for a subsection subsections_per_state &lt;- plot_attributes_drop_geo |&gt; select(STATECD, ECOSUBCD) |&gt; distinct() |&gt; right_join(eco, by = join_by(ECOSUBCD == SUBSECTION)) subsections_all &lt;- subsections_per_state |&gt; select(-STATECD) |&gt; group_by(ECOSUBCD) |&gt; distinct() ## Get list of which states a subsection occurs - will help with data viz interpretation later subsection_state_list &lt;- subsections_per_state |&gt; select(STATECD, ECOSUBCD) |&gt; distinct() |&gt; left_join(state_codes, by = join_by(STATECD == st)) |&gt; select(-STATECD, -stname) |&gt; arrange(stusps) |&gt; pivot_wider(names_from = stusps, values_from = stusps) |&gt; unite(&quot;states&quot;, CT:VT, remove = FALSE, na.rm = TRUE, sep = &quot; &quot;) |&gt; mutate(states = paste0(&quot;(&quot;,states,&quot;)&quot;)) |&gt; select(ECOSUBCD, states) ## Abbrivations to shorten subsection names replace_list &lt;- (c(&quot;Mountain&quot; = &quot;Mt&quot;, &quot;Central&quot; = &quot;C.&quot;, &quot;Northern&quot; = &quot;N.&quot;, &quot;Southern&quot; = &quot;S.&quot;, &quot;Eastern&quot; = &quot;E.&quot;, &quot;New Brunswick&quot; = &quot;NB&quot;, &quot;Lowlands&quot; = &quot;Lowl.&quot;, &quot;Lowland&quot; = &quot;Lowl.&quot;, &quot;Uplands&quot; = &quot;Upl.&quot;, &quot;Upland&quot; = &quot;Upl.&quot;, &quot;Plateau&quot; = &quot;Plat.&quot;, &quot;Piedmont&quot; = &quot;Pdmt&quot;, &quot;Blue&quot; = &quot;Bl.&quot;, &quot;Ridge&quot; = &quot;Rdg&quot;, &quot;Valley&quot; = &quot;Vly&quot;, &quot;Maine&quot; = &quot;ME&quot;, &quot;Connecticut&quot; = &quot;CT&quot;, &quot;Vermont&quot; = &quot;VT&quot;, &quot;Virginia&quot; = &quot;VA&quot;, &quot;Western&quot; = &quot;W.&quot;, &quot;Glacial Lake and Marine Plains&quot; = &quot;GL/MP&quot;, &quot;Hills and Plains&quot; = &quot;&quot;, &quot;Kittatinny-Shawangunk&quot; = &quot;Kitt-Shaw&quot;, &quot;Metasedimentary&quot; = &quot;Meta&quot;, &quot;Mahoosic Rangely Lakes&quot; = &quot;Mahoo/Rng Lks&quot;, &quot;Highlands&quot; = &quot;Highl.&quot;, &quot;Hudson&quot; = &quot;Hud.&quot;, &quot;Limestone&quot; = &quot;Limstn&quot;, &quot;Gettysburg&quot; = &quot;Getty&quot;, &quot;Sebago-Ossipee&quot; = &quot;Seb-Ossipee&quot;, &quot;Berkshire&quot; = &quot;Berk&quot;, &quot;Embayment&quot; = &quot;Embaymt&quot;, &quot;International&quot; = &quot;Int.&quot;, &quot;Plateau&quot; = &quot;Plat.&quot; )) subsections_abbr &lt;- subsections_all |&gt; left_join(subsection_state_list, by = join_by(ECOSUBCD)) |&gt; mutate(SUBSECT_ABBR = str_replace_all(SUBSECTI_1, replace_list)) |&gt; unite(&quot;SUBSECT_ABBR_ST&quot;, SUBSECT_ABBR:states, remove = FALSE, na.rm = TRUE, sep = &quot; &quot;) 3.5.4 Save subsection attributes # append n plot counts for entire dataset and most recent subsection_attributes &lt;- subsections_abbr |&gt; left_join(n_plots_tpa, by = join_by(ECOSUBCD)) |&gt; left_join(n_plots_tpa_MR, by = join_by(ECOSUBCD)) saveRDS(subsection_attributes, file = paste0(save_location, &quot;subsection_attributes.rds&quot;)) 3.5.5 Save centroids section_centroids &lt;- subsection_attributes |&gt; sf::st_as_sf() |&gt; group_by(SECTION_NA) |&gt; summarise(geometry = sf::st_union(geometry)) |&gt; sf::st_centroid() |&gt; mutate(X = sf::st_coordinates(geometry)[,1], Y = sf::st_coordinates(geometry)[,2]) ## Warning: st_centroid assumes attributes are constant over geometries str(section_centroids) ## sf [19 × 4] (S3: sf/tbl_df/tbl/data.frame) ## $ SECTION_NA: chr [1:19] &quot;Allegheny Mountains&quot; &quot;Aroostook Hills and Lowlands&quot; &quot;Blue Ridge Mountains&quot; &quot;Catskill Mountains&quot; ... ## $ geometry :sfc_POINT of length 19; first list element: &#39;XY&#39; num [1:2] -80.8 37.5 ## $ X : num [1:19] -80.8 -68.6 -81.9 -74.5 -79.4 ... ## $ Y : num [1:19] 37.5 45.9 36.4 42 37.4 ... ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA ## ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;SECTION_NA&quot; &quot;X&quot; &quot;Y&quot; subsection_centroids &lt;- subsection_attributes |&gt; sf::st_as_sf() |&gt; sf::st_centroid() ## Warning: st_centroid assumes attributes are constant over geometries ## leaflet map ecosubCol &lt;- colorFactor(rainbow(51), subsection_attributes$SUBSECT_ABBR) subsection_attributes |&gt; sf::st_as_sf() |&gt; leaflet() |&gt; addTiles() |&gt; addPolygons(color = ~ecosubCol(SUBSECT_ABBR), label = ~SUBSECT_ABBR) |&gt; addCircleMarkers(data = subsection_centroids, color = ~ecosubCol(SUBSECT_ABBR), stroke = FALSE, fillOpacity = 1, radius = 10, label = ~SUBSECT_ABBR) |&gt; addCircleMarkers(data = section_centroids, color = &quot;black&quot;, stroke = FALSE, fillOpacity = 1, radius = 10, label = ~SECTION_NA) ## Warning in validateCoords(lng, lat, funcName): Data contains 1 rows with either ## missing or invalid lat/lon values and will be ignored saveRDS(section_centroids, file = paste0(save_location, &quot;section_centroids.rds&quot;)) saveRDS(subsection_centroids, file = paste0(save_location, &quot;subsection_centroids.rds&quot;)) A centroid file was in original repo - but not sure how it was created - took a stab here. Check map above to see if method was acceptable. 3.5.6 Save plot attributes # create list of abbreviated subsection to append to plot attributes table sub_attributes_for_plots &lt;- subsection_attributes %&gt;% select(ECOSUBCD, PROVINCE, SECTION, DOMAIN_NAM, DIVISION_N, PROVINCE_N, SECTION_NA, SUBSECTI_1,ATIntersec, SUBSECT_ABBR, SUBSECT_ABBR_ST, states) ## Plot attributes unique locations plot_attributes_final &lt;- plot_attributes |&gt; right_join(sub_attributes_for_plots, by = join_by(ECOSUBCD)) |&gt; select(-STATECD) ## Plot attributes by year plot_attributes_drop_geom &lt;- plot_attributes_final |&gt; sf::st_drop_geometry() plot_attributes_by_year_final &lt;- tpa_plots_by_year |&gt; select(YEAR, pltID) |&gt; left_join(plot_attributes_drop_geom, by = join_by(pltID)) saveRDS(plot_attributes_final, file = paste0(save_location, &quot;plot_attributes_locations.rds&quot;)) saveRDS(plot_attributes_by_year_final, file = paste0(save_location, &quot;plot_attributes_by_year.rds&quot;)) 3.5.6.1 join subsection attributes to eco eco_final &lt;- eco |&gt; left_join(subsection_attributes) saveRDS(eco_final, file = paste0(save_location, &quot;eco.rds&quot;)) 3.6 Check plot attributes final Note the new Ecosubsection names and ability to detect subsections without FIA plots # Visualize plot distance x elevation with plot_attributes_final plot_attributes_final_graph &lt;- na.omit(plot_attributes_final) plots_na &lt;- plot_attributes_final |&gt; filter(is.na(pltID)) |&gt; pull(SUBSECT_ABBR) plots_na &lt;- paste(&quot;Subsections without plot data:&quot;, paste(plots_na, collapse = &quot;, &quot;)) plot_attributes_final_graph |&gt; group_by(ECOSUBCD)|&gt; mutate(median_dist = median(distance_m)) |&gt; mutate(median_elev = median(ELEV)) |&gt; ggplot(aes(x= fct_reorder(SUBSECT_ABBR_ST, distance_m), y=ELEV, fill = as.factor(median_elev))) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), legend.position = &#39;none&#39;) + xlab(&quot;Ecosubsection (from SW to NE)&quot;) + ylab(&quot;Plot Elevation&quot;) + labs(caption = plots_na) ## Vizualize plots per year # Visualize number of plots per subsection per year n_plots_per_year &lt;- tpa_plots |&gt; sf::st_drop_geometry() |&gt; group_by(ECOSUBCD, YEAR) |&gt; summarize(n_plots_per_year = n(), .groups = &#39;drop&#39;) |&gt; right_join(subsection_attributes, by = join_by(ECOSUBCD)) n_plots_per_year_graph &lt;- na.omit(n_plots_per_year) n_plots_per_year_graph %&gt;% mutate(highlight = case_when(n_plots_per_year == 1 ~ &quot;1 plot&quot;, n_plots_per_year == 2 ~ &quot;2 plots&quot;, .default = NA)) %&gt;% ggplot(aes(x=forcats::fct_reorder(SUBSECT_ABBR_ST, median_distance), y=YEAR, size = n_plots_per_year, color = highlight)) + geom_count() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + scale_size_area() + scale_color_manual(values = c(&quot;red2&quot;, &quot;cyan3&quot;, &quot;grey50&quot;), breaks = c(&quot;1 plot&quot;, &quot;2 plots&quot;)) + xlab(&quot;Ecosubsection (from SW to NE)&quot;) + labs(caption = plots_na) "],["make.html", "Chapter 4 Make 4.1 Load data 4.2 Save location 4.3 Metrics 4.4 Live tree abundance 4.5 Species diversity of live trees 4.6 Tree growth rates 4.7 Forest demographic rates 4.8 Regeneration abundance 4.9 Snags 4.10 Down woody material 4.11 Invasive plant abundance 4.12 Stand structural stage distributions", " Chapter 4 Make 4.1 Load data Location where data was saved from previous chapter (clip) ## default location: load_location_default &lt;- &#39;./clip_FIA/&#39; ## custom location: load_location_custom &lt;- &#39;C:/Users/JJGross/Documents/R_projects/FIA_data/clip_FIA/&#39; #set variable load_location &lt;- load_location_custom Load data and set as default argument variables ## Load most recent (MR) Appalachian trail (at) dataset: at_MR &lt;- read_rds(file = paste0(load_location, &quot;at_FIA_MR.rds&quot;)) ## Load entire Appalachian trail (at) dataset: at &lt;- read_rds(file = paste0(load_location, &quot;at_FIA.rds&quot;)) ## Load eco eco &lt;- read_rds(file = paste0(load_location, &quot;eco.rds&quot;)) ## Set default variables for rFIA function: database_variable &lt;- at polys_variable &lt;- eco 4.2 Save location Choose where final tables will be saved: ## default location: save_default &lt;- &#39;./summary_data/&#39; ## Alternatively, enter specific custom location: save_custom &lt;- &#39;C:/Users/JJGross/Documents/R_projects/FIA_data/summary_data/&#39; save_location &lt;- save_custom ## Create directory if it doesn&#39;t already exist if (!dir.exists(save_location)) {dir.create(save_location)} 4.3 Metrics Derive population estimates (at the plot- or the ecoregion-scale) for each forest health metric: Live tree abundance tpa tpa_spp tpa_spp_sizecl biomass Species diversity of live trees diversity Tree vital rates growth Forest demographic rates mortality Regeneration abundance seedlings seedlings_spp saplings saplings_spp saplings_sizecl Snags snag_abundance dead_and_live_tpa snag_volume Down woody material downwoody Invasive plant abundance invasive Stand structural stage distributions ss Each of the following subsections illustrates how to use the variety of functions in rFIA to calculate these metrics. 4.3.1 Argument Variables Are plot-level records desired within each SUBSECTION? If so, run the entire 03-make.Rmd with by_plot_variable set to TRUE. Otherwise, leave by_plot_variable &lt;- FALSE to aggregate FIA plots at SUBSECTION level. by_plot_variable &lt;- FALSE means tables are summarized at SUBSECTION-level by_plot_variable &lt;- TRUE means tables are summarized at the FIA plot-level by_plot_variable &lt;- FALSE most_recent &lt;- FALSE means all FIA plots are included in the data tables most_recent &lt;- TRUE means only the most recent FIA plots are included most_recent &lt;- TRUE The code chunk below automatically updates argument variables and folder save location based on above user input (blue boxes) to by_plot_variable and most_recent. Code chunk also specifies the number of processing cores to use during the execution of rFIA functions. See the rFIA webpage Tips for working with Big Data for more information. ## save tables to new folder if by_plot_variable is TRUE if (by_plot_variable == TRUE) { # new save location folder ifelse(!dir.exists(file.path(save_location)), dir.create(file.path(save_location)), FALSE) save_location &lt;- paste0(save_location, &quot;by_plot_variable/&quot;) } ## if &#39;most_recent == TRUE&#39;, than change database_variable to &#39;at_MR&#39; database ## and create new folder to save MR tables to. if (most_recent == TRUE) { database_variable &lt;- at_MR # new save location folder ifelse(!dir.exists(file.path(save_location, &quot;most_recent&quot;)), dir.create(file.path(save_location, &quot;most_recent&quot;)), FALSE) save_location &lt;- paste0(save_location, &quot;most_recent/&quot;) } ## default number of processing cores to utilize in rFIA function arguments below. cores_variable &lt;- parallel::detectCores()-2 4.3.2 Population estimate method Functions in rFIA can be used to derive population estimates of forest data using 5 unique estimators (i.e. different methods for panel combination) using the method argument in each function. For the purposes of forest population estimation for APPA, only the method = ANNUAL argument is used (i.e. no panel combination). For more information on panel combinations see the rFIA Alternative design-based estimators page. ## Set method variable for rFIA function arguments here: method_variable &lt;- &quot;ANNUAL&quot; Note that when using method = \"ANNUAL\" all rFIA:: functions result with the following error message: “Bad stratification, i.e., strata too small to compute variance of annual panels. If you are only interested in totals and/or ratio estimates, disregard this. However, if interested in variance (e.g., for confidence intervals) try using method =”TI”.” 4.4 Live tree abundance The rFIA::tpa() function Produces tree per acre (TPA) and basal area per acre (BAA) estimates from FIA data, along with population totals for each variable. Options to group estimates by species, size class, and other variables defined in the FIADB. Argument treeDomain = DIA \\&gt;= 5 results in estimates only utilizing tree diameters above 5 inches DBH. 4.4.1 tpa ## Trees per Acre (species and size classes lumped) tpa &lt;- rFIA::tpa( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, treeType = &quot;live&quot;, totals = TRUE, treeDomain = DIA &gt;= 5 ) saveRDS(tpa, paste0(save_location, &quot;tpa.rds&quot;)) 4.4.2 tpa_spp ## Trees per Acre by species (size-classes lumped) tpa_spp &lt;- rFIA::tpa( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, treeType = &quot;live&quot;, totals = TRUE, treeDomain = DIA &gt;= 5, bySpecies = TRUE, bySizeClass = FALSE ) saveRDS(tpa_spp, paste0(save_location, &quot;tpa_spp.rds&quot;)) 4.4.3 tpa_spp_sizecl ## Trees per Acre (by species and size-class) tpa_spp_sizecl &lt;- rFIA::tpa( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, treeType = &quot;live&quot;, totals = TRUE, treeDomain = DIA &gt;= 5, bySpecies = TRUE, bySizeClass = TRUE ) saveRDS(tpa_spp_sizecl, paste0(save_location, &quot;tpa_spp_sizecl.rds&quot;)) 4.4.4 biomass The rFIA::biomass() function produces estimates of volume (cu.ft./acre), biomass (tons/acre), and carbon (tons/acre) with options to group estimates by species, size class, and other variables defined in the FIADB. ## biomass (by species and size-class) # biomass &lt;- rFIA::biomass(db = database_variable, # byPlot = by_plot_variable, # polys = polys_variable, # method = method_variable, # nCores = cores_variable, # returnSpatial = TRUE, # treeType = &quot;live&quot;, # totals = TRUE, # treeDomain = DIA &gt;= 5, # bySpecies = TRUE, # bySizeClass = TRUE) # saveRDS(biomass, paste0(save_location, &quot;biomass.rds&quot;)) Note that the rFIA::biomass() function currently produces the following error and needs attention from package developers. Error in fcase(is.na(DIA), NA_real_, !is.na(DRYBIO_WDLD_SPP), DRYBIO_WDLD_SPP/(jTotal - : object ‘DRYBIO_WDLD_SPP’ not found 4.5 Species diversity of live trees The rFIA::diversity() function produces estimates of diversity from FIA data. Returns Shannon’s Index (H), Shannon’s Equitability (Eh), and Richness (S) for alpha (mean/SE of stands), beta, and gamma diversity. Default behavior estimates species diversity, using TPA as a state variable and Species Code (SPCD) to groups of individuals. 4.5.1 diversity ## Diversity diversity &lt;- rFIA::diversity( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, treeType = &quot;live&quot;, totals = TRUE, treeDomain = DIA &gt;= 5 ) saveRDS(diversity, paste0(save_location, &quot;diversity.rds&quot;)) 4.6 Tree growth rates The rFIA::vitalRates() function computes estimates of average annual DBH (inches/ yr), basal area (sq. ft./ yr), biomass (short tons/ yr), and net volume (cu. ft./yr) growth rates for individual stems, along with average annual basal area and net volume growth per acre. To calcuate by size class include argument bySizeClass =TRUE To estimate net growth rates (include trees that have recruited or died in estimates), use treeType = 'all' (default) To exclude stems that died or recruited into the population between plot measurements set treeType = 'live' 4.6.1 growth ## Tree DBH growth growth &lt;- rFIA::vitalRates( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, treeType = &quot;live&quot;, totals = TRUE, treeDomain = DIA &gt;= 5, bySpecies = TRUE, variance = TRUE # note error message: &quot;Bad stratification, i.e., strata too small to compute variance of annual panels.&quot; ) saveRDS(growth, paste0(save_location, &quot;growth.rds&quot;)) 4.7 Forest demographic rates The rFIA::growMort() function estimates of annual growth, recruitment, natural mortality, and harvest rates, along with population estimates for each variable. Recruitment events are defined as when a live stem which is less than 5 inches DBH at time 1, grows to or beyond 5 inches DBH by time 2. This does NOT include stems which grow beyond the 5-inch diameter criteria and are then subject to mortality prior to remeasurement. Natural mortality is defined as when a live stem is subject to non-harvest mortality between successive measurement periods. Finally, harvest is defined as when a live stem is cut and removed between successive measurements. 4.7.1 mortality To estimate mortality per species: ## mortality mortality &lt;- rFIA::growMort( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, treeType = &quot;all&quot;, #default, includes all stems, live and dead totals = TRUE, treeDomain = DIA &gt;= 5, bySpecies = TRUE, variance = TRUE # note error message: &quot;Bad stratification, i.e., strata too small to compute variance of annual panels.&quot; ) saveRDS(mortality, paste0(save_location, &quot;mortality.rds&quot;)) Column mortality$MORT_PERC results in Inf for each row. Suspected error with rFIA::growMort() because none of the tables produced had any values in MORT_PREC 4.8 Regeneration abundance The rFIA::seedlings() and rFIA::tpa() functions are used to estimate regeneration of seedlings and sapling, respectively. Note that querying saplings can be achieved within the rFIA::tpa() function by setting the tree domain argument treeDomain = DIA &lt; 5. Stems below 1 inch DBH are not included in output of rFIA::tpa() because FIA seedlings (&lt;1 inch DBH) are sampled differently and therefore queried using the distinct rFIA::seedlings() function. 4.8.1 seedlings Seedling abundance (trees per acre) is computed using the distinct rFIA::seedlings() function, not the rFIA::tpa() function. The FIA glossary defines seedlings as: “Live trees smaller than 1.0 inch (2.5 cm) d.b.h./d.r.c. that are at least 6 inches (15.2 cm) in height for softwoods and 12-inches (30.5 cm) in height for hardwoods.” ## Trees per acre of seedlings (&lt;1 inch DBH) seedlings &lt;- rFIA::seedling( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, totals = TRUE ) saveRDS(seedlings, paste0(save_location, &quot;seedlings.rds&quot;)) 4.8.2 seedlings_spp ## Trees per acre of seedlings by species seedlings_spp &lt;- rFIA::seedling( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, totals = TRUE, bySpecies = TRUE # by species ) saveRDS(seedlings_spp, paste0(save_location, &quot;seedlings_spp.rds&quot;)) 4.8.3 saplings Saplings must use rFIA::tpa() function with treeDomain = DIA &lt; 5 argument To estimate sapling size class (1 to 4.9 inch DBH). ## Trees per acre of saplings (trees greater than 1 inch DBH, and less than 5 inch DBH) saplings &lt;- rFIA::tpa( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, treeType = &quot;live&quot;, totals = TRUE, treeDomain = DIA &lt; 5 ) saveRDS(saplings, paste0(save_location, &quot;saplings.rds&quot;)) 4.8.4 saplings_spp ## Trees per acre of saplings by species saplings_spp &lt;- rFIA::tpa( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, treeType = &quot;live&quot;, totals = TRUE, treeDomain = DIA &lt; 5, bySpecies = TRUE, # by species bySizeClass = FALSE ) saveRDS(saplings_spp, paste0(save_location, &quot;saplings_spp.rds&quot;)) 4.8.5 saplings_sizecl ## Trees per acre of saplings by size class saplings_sizecl &lt;- rFIA::tpa( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, treeType = &quot;live&quot;, totals = TRUE, treeDomain = DIA &lt; 5, bySpecies = FALSE, bySizeClass = TRUE # by size class ) saveRDS(saplings_sizecl, paste0(save_location, &quot;saplings_sizecl.rds&quot;)) 4.9 Snags rFIA::tpa() and rFIA::biomass() can be used to estimate snag abundance, volume, and percentage. 4.9.1 snag_abundance treeType = \"dead\" bySizeClass = TRUE ## Snags per acre snag_abundance &lt;- rFIA::tpa( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, treeType = &quot;dead&quot;, totals = TRUE, treeDomain = DIA &gt;= 5, bySizeClass = TRUE ) saveRDS(snag_abundance, paste0(save_location, &quot;snag_abundance.rds&quot;)) 4.9.2 dead_and_live_tpa treeType = \"all\" includes both live and dead trees in calculations. Use grpBy = STATUSCD to avoid lumping Live and Dead tree. STATUSCD (From The FIA Database User Guide) STATUSCD Description 0 No status - Tree is not presently in the sample (remeasurement plots only). Tree was incorrectly tallied at the previous inventory, currently not tallied due to definition or procedural change, or is not tallied because it is located on a nonsampled condition (e.g., hazardous or denied). RECONCILECD = 5-9 required for remeasured annual inventory data but not for periodic inventory data. 1 Live tree 2 Dead tree 3 Removed - Cut and removed by direct human activity related to harvesting, silviculture or land clearing. This tree is assumed to be utilized. ## dead and live trees - to calculate percent snags dead_and_live_tpa &lt;- rFIA::tpa( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, treeType = &quot;all&quot;, grpBy = STATUSCD, totals = TRUE, treeDomain = DIA &gt;= 5, bySizeClass = TRUE ) dead_and_live_tpa &lt;- dead_and_live_tpa |&gt; filter(STATUSCD == 1 | STATUSCD == 2) |&gt; #only interested in live and dead mutate(tree_status = case_when(STATUSCD == 1 ~ &quot;Live&quot;, STATUSCD == 2 ~ &quot;Dead&quot;, #anything else will result in NA TRUE ~ NA)) saveRDS(dead_and_live_tpa, paste0(save_location, &quot;dead_and_live_tpa.rds&quot;)) 4.9.3 snag_volume # ## Snag Volume # snag_volume &lt;- rFIA::biomass( # db = database_variable, # byPlot = by_plot_variable, # polys = polys_variable, # method = method_variable, # nCores = cores_variable, # returnSpatial = TRUE, # treeType = &quot;dead&quot;, # totals = TRUE, # treeDomain = DIA &gt;= 5 # ) # saveRDS(snag_volume, paste0(save_location, &quot;snag_volume.rds&quot;)) Note that the rFIA::biomass() function currently produces the following error and needs attention from package developers. Error in fcase(is.na(DIA), NA_real_, !is.na(DRYBIO_WDLD_SPP), DRYBIO_WDLD_SPP/(jTotal - : object ‘DRYBIO_WDLD_SPP’ not found 4.10 Down woody material rFIA::dwm() produces estimates of down woody material stocks. Estimates are returned by fuel class (duff, litter, 1HR, 10HR, 100HR, 1000HR, piles) for application in fuels management. 1HR fuels: small, fine woody debris 10HR fuels: medium, fine woody debris 100HR fuels: large, fine woody debris 1000HR fuels: coarse woody debris and slash piles duff: O horizon; all unidentifiable organic material above mineral soil, beneath litter litter: identifiable plant material which is downed and smaller than 10HR fuel class (1HR class includes standing herbaceous material). 4.10.1 downwoody ## Down woody material downwoody &lt;- rFIA::dwm( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, totals = TRUE ) saveRDS(downwoody, paste0(save_location, &quot;downwoody.rds&quot;)) 4.11 Invasive plant abundance The rFIA::invasive() function produces estimates of the areal coverage (%) of invasive species and frequency of plots invasive species were detected in. 4.11.1 invasive ## invasive invasive &lt;- rFIA::invasive( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, totals = TRUE, variance = TRUE # note error message: &quot;Bad stratification, i.e., strata too small to compute variance of annual panels.&quot; ) saveRDS(invasive, paste0(save_location, &quot;invasive.rds&quot;)) 4.12 Stand structural stage distributions The rFIA::standStruct() function estimates forest structural stage distributions as percent forested land area in pole, mature, late, and mosaic stages and returns the stand structural stage distribution of an area of forest/timberland from FIA data. Description: Estimates of forest structural stage distributions as percent forested land area in pole, mature, late, and mosaic stages Diameter Classes: Pole: 11 - 25.9 cm Mature: 26 - 45.9 cm Large: 46+ cm Structural Stage Classification: Pole Stage: &gt; 67% BA in pole and mature classes, with more BA in pole than mature. Mature Stage: &gt; 67% BA in pole and mature classes, with more BA in mature than pole OR &gt; 67% BA in mature and large classes, with more BA in mature. Late-Successional Stage:: &gt; 67% BA in mature and large classes, with more in large. Mosiac:: Any plot not meeting above criteria. 4.12.1 ss ## stand structural stage ss &lt;- rFIA::standStruct( db = database_variable, byPlot = by_plot_variable, polys = polys_variable, method = method_variable, nCores = cores_variable, returnSpatial = TRUE, totals = TRUE ) saveRDS(ss, paste0(save_location, &quot;ss.rds&quot;)) "],["references.html", "Chapter 5 References", " Chapter 5 References Bechtold, W.A.; Patterson, P.L., eds. 2005. The Enhanced Forest Inventory and Analysis Program - National Sampling Design and Estimation Procedures. Gen. Tech. Rep. SRS - 80. Asheville, NC: U.S. Department of Agriculture, Forest Service, Southern Research Station. 85 p. https://www.srs.fs.usda.gov/pubs/gtr/gtr_srs080/gtr_srs080.pdf Cleland, D.T.; Freeouf, J.A.; Keys, J.E.; Nowacki, G.J.; Carpenter, C.A.; and McNab, W.H. 2007. Ecological Subregions: Sections and Subsections for the conterminous United States. Gen. Tech. Report WO-76D [Map on CD-ROM] (A.M. Sloan, cartographer). Washington, DC: U.S. Department of Agriculture, Forest Service, presentation scale 1:3,500,000; colored. https://doi.org/10.2737/WO-GTR-76D Dieffenbach, F. (2018). Appalachian National Scenic Trail forest health monitoring protocol, Natural Resource Report NPS/NETN/NRR—2018/1804. National Park Service, Fort Collins, Colorado. https://irma.nps.gov/DataStore/DownloadFile/610353 Stanke, H., Finley, A. O., Weed, A. S., Walters, B. F., &amp; Domke, G. M. (2020). rFIA: An R package for estimation of forest attributes with the US Forest Inventory and Analysis database. Environmental Modelling &amp; Software, 127, 104664. https://doi.org/10.1016/j.envsoft.2020.104664 Woodall, C.; Monleon, V.J., eds. 2007. Sampling Protocol, Estimation, and Analysis Procedures for the Down Woody Materials Indicator of the FIA Program. Gen. Tech. Rep. NRS - 22. Newtown Square, PA: U.S. Department of Agriculture, Forest Service, Northern Research Station. https://www.nrs.fs.fed.us/pubs/gtr/gtr_nrs22.pdf FIA Database User Guide: https://www.fia.fs.fed.us/library/database-documentation/ "],["revision-history.html", "Chapter 6 Revision History", " Chapter 6 Revision History Version numbers will be incremented by a whole number (e.g., Version 1.3 to 2.0) when a change is made that significantly affects requirements or procedures. Version numbers will be incremented by decimals (e.g., Version 1.06 to Version 1.07) when there are minor modifications that do not affect requirements or procedures included in the protocol. Add rows as needed for each change or set of changes tied to an updated version number. Revision History Log Version # Date Revised by Changes Justification 1.00 July 2017 Fred Dieffenbach Initial Version 2.00 May 2020 Aaron Weed Updated and merged prior versions of SOPs 1 and 2 into this SOP to incorporate new R-based FIA data workflow utilizing ther rFIA package. These changes were made because former workflow using MS Access downloads from FIA are no longer supported and because analysis workflow for estimating metrics was updated. 3.00 Feb 2024 Jacob Gross &amp; Aaron Weed Revised so SOP and code to download, clip, and summarize the data tables are one and the same. Edits for clarity. Former SOP was was like a tutorial on how to use rFIA functions. It was separate from APPA forest health report and quickly became out of date due to evolving nature of the rFIA package and the APPA Forest Health Rmarkdown report. New approach reduces the number of files/documents needing managed. And tables generated from SOP should feed directly into forest health report. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
